<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Redis 速览 | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Redis 速览</h2>
  <p class="post-date">2023-04-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是一种<code>基于内存</code>的开源数据库，读写操作都是在内存中完成，所以读写速度非常快，常用于<code>缓存</code>、<code>消息队列</code>、<code>分布式锁</code>等场景。</p>
<p>提供多种数据类型：<code>String（字符串）</code>、<code>Hash（哈希）</code>、<code>List（列表）</code>、<code>Set（集合）</code>、<code>ZSet（有序集合）</code>、<code>Bitmaps（位图）</code>、<code>HyperLogLog（基数统计）</code>、<code>GEO（地理信息）</code>、<code>Stream（流）</code>。</p>
<p>对数据类型的操作都由<mark>单线程完成，是原子性的，无并发问题</mark>。</p>
<p>支持<code>事务</code>、<code>持久化</code>、<code>Lua 脚本</code>、<code>多种集群方案（主从一致、哨兵、切片机集群）</code>、<code>发布/订阅模式</code>、<code>内存淘汰机制</code>、<code>过期删除机制</code>等。</p>
<h2 id="Redis-和-Memcached-区别"><a href="#Redis-和-Memcached-区别" class="headerlink" title="Redis 和 Memcached 区别"></a>Redis 和 Memcached 区别</h2><p><code>共同点</code>：</p>
<ul>
<li>都是基于内存的数据库，都被用来当缓存</li>
<li>都有过期策略</li>
<li>性能都很高</li>
</ul>
<p><code>区别</code>：</p>
<ul>
<li>Redis 支持的数据类型更丰富；Memcached 只支持 &lt;key-value&gt; 数据类型</li>
<li>Redis 有持久化功能，可将内存中的数据保存在磁盘上；Memcached 没有持久化功能，重启电脑，数据全无</li>
<li>Redis 原生支持集群模式；Memcached 无集群模式</li>
<li>Redis 支持发布&#x2F;订阅模式、Lua 脚本、事务等功能；Memcached 则不支持</li>
</ul>
<h2 id="为什么要用-Redis"><a href="#为什么要用-Redis" class="headerlink" title="为什么要用 Redis"></a>为什么要用 Redis</h2><p>为什么要用 Redis 作为 MySQL 的缓存？</p>
<p>因为 Redis 的「高性能」与「高并发」两特性。</p>
<ul>
<li><code>高性能</code>：对数据库内存的访问速度没有对缓存的访问快，操作 Redis 就是直接操作内存<ul>
<li><code>不足</code>：数据库中数据发生变化，需要同步修改 Redis，发生双写一致性问题</li>
</ul>
</li>
<li><code>高并发</code>：处理速度远大于 MySQL，能承受更大的请求压力，某些场景下可以将数据库中的部分数据存放在 Redis 里</li>
</ul>
<h1 id="常见面试题速览"><a href="#常见面试题速览" class="headerlink" title="常见面试题速览"></a>常见面试题速览</h1><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="有哪些数据类型、使用场景？"><a href="#有哪些数据类型、使用场景？" class="headerlink" title="有哪些数据类型、使用场景？"></a>有哪些数据类型、使用场景？</h3><p>常见的有五种数据类型，及其使用场景：</p>
<ul>
<li><p><code>String（字符串）</code>：缓存对象、常规计数、分布式锁、共享 session 等信息</p>
</li>
<li><p><code>Hash（哈希）</code>：缓存对象、购物车</p>
</li>
<li><p><code>List（列表）</code>：消息队列（存在两个问题：1. 生产者需要自行生成全局唯一 id；2. 不能以消费组的形式消费数据）</p>
<ul>
<li><blockquote>
<p>如何保证消息有序？：List 本身就是先入先出的顺序。</p>
<p>额外开销如何处理？：List 作为消息队列时，生产者不会通知消费者数据的写入，消费者需要不断调用读取方法，尝试消费消息队列里的消息，如果消息队列里没有内容，则消费者空转，带来性能消耗。解决：阻塞式读取，客户端没有读到队列数据时自动阻塞，有新数据存入消息队列时，消费者才开始读取新数据。</p>
<p>重复消息如何处理？：每个消息有唯一全局 id，消费者比对读取的消息 id 和已处理的消息的 id 来判断消息是否已处理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>Set（集合）</code>：聚合计算（并集、交集、差集），如：点赞、关注、抽奖等</p>
</li>
<li><p><code>ZSet（有序集合）</code>：排序场景，如：排行榜、电话和姓名排序等</p>
</li>
</ul>
<p>后来，又支持四种数据类型：</p>
<ul>
<li><code>BitMap（位图）</code>：二值状态统计场景，如：签到、判断用户的登录状态</li>
<li><code>HyperLogLog（基数统计）</code>：海量数据的基数统计，如：网站 UV 统计</li>
<li><code>GEO（地理信息）</code>：存储地理位置信息，如：滴滴打车</li>
<li><code>Stream（流）</code>：消息队列（解决了 List 的两个问题：1. 可以自动生成全局唯一 id；2. 支持以消费组的形式消费数据）</li>
</ul>
<h3 id="五种常见的数据类型是如何实现的？"><a href="#五种常见的数据类型是如何实现的？" class="headerlink" title="五种常见的数据类型是如何实现的？"></a>五种常见的数据类型是如何实现的？</h3><p><img src="/../pictures/image-20230403024651823.png" alt="image-20230403024651823"></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><p><code>数据结构</code>：「SDS（简单动态字符串）」</p>
</li>
<li><p>SDS 有如下特点：</p>
<ul>
<li><p>不仅可以保存文本数据，也可以保存<mark>二进制数据</mark>，也就是说可以保存图片、视频、音频等信息</p>
</li>
<li><p>获取字符串长度的时间复杂度是 <mark>O(1)</mark></p>
</li>
<li><p><mark>API 安全</mark>，拼接字符串不会溢出，因为拼接之前会去检查空间是否足够，不足时会扩容</p>
</li>
</ul>
</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「双向链表」或「压缩列表」，最新版本用的「quicklist」</li>
<li>使用：<ul>
<li>如果元素个数小于 512 个（默认值），每个元素小于 64 字节（默认值），Redis 使用「压缩列表」作为 List 的数据结构</li>
<li>否则使用「双向链表」</li>
<li>Redis3.2 之后一律使用「quicklist」</li>
</ul>
</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「压缩列表」或「哈希表」，最新版本用的「listpack」或「哈希表」</li>
<li>使用：和 List 很像<ul>
<li>元素个数小于 512 个（默认值），所有值小于 64 字节（默认值），使用「压缩列表」</li>
<li>否则使用「哈希表」</li>
<li>最新版本中实用「listpack」代替「压缩列表」</li>
</ul>
</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>数据结构</code>：「哈希表」或「整数集合」</li>
<li>使用：<ul>
<li>元素均为整数，元素个数小于 512 个（默认值），使用「整数集合」</li>
<li>否则使用「哈希表」</li>
</ul>
</li>
</ul>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><ul>
<li><code>数据结构</code>：Redis3.0 时用的「压缩列表」或「跳表」，最新版本用的「listpack」或「跳表」</li>
<li>使用：<ul>
<li>有序集合的元素个数小于 128 个，每个元素值小于 64 字节，使用「压缩列表」</li>
<li>否则使用「跳表」</li>
<li>最新版本中使用「listpack」代替「压缩列表」</li>
</ul>
</li>
</ul>
<h2 id="😅-Redis-数据结构"><a href="#😅-Redis-数据结构" class="headerlink" title="😅 Redis 数据结构"></a>😅 Redis 数据结构</h2><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-的单线程"><a href="#Redis-的单线程" class="headerlink" title="Redis 的单线程"></a>Redis 的单线程</h3><p>Redis 的单线程指的是<mark>「接收客户端请求 —&gt; 解析请求 —&gt; 处理请求 —&gt; 响应请求」这一过程是单线程的</mark>。</p>
<p>但 Redis 程序并不是单线程的，Redis 启动之后也会开启三个后台线程：</p>
<ul>
<li><code>BIO_CLOSE_FILE</code>：关闭文件</li>
<li><code>BIO_AOF_FSYNC</code>：AOF 刷盘</li>
<li><code>BIO_LAZY_FREE</code>：异步释放内存</li>
</ul>
<p>当客户端发出「关闭文件、AOF 刷盘或释放内存」的请求时，如果将其放在主线程里执行，会因为这三个任务都比较耗时导致阻塞，所以将这三个任务扔到任务队列中，由 BIO 不断轮询处理队列中的任务。</p>
<h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><ul>
<li><code>内存中执行 + 高效的数据结构</code>：Redis 的瓶颈在于「网络带宽」或「内存大小」，而非 CPU</li>
<li><code>单线程</code>：没有使用多线程，也就避免了「线程切换开销」和「死锁问题」</li>
<li><code>I/O 多路复用机制</code>：一个线程处理多个 IO 流，即「select&#x2F;epoll 机制」</li>
</ul>
<h3 id="为什么引入多线程？"><a href="#为什么引入多线程？" class="headerlink" title="为什么引入多线程？"></a>为什么引入多线程？</h3><p>早期 Redis 的网络 I&#x2F;O 和执行命令都是单线程的，因为制约 Redis 的不在于 CPU，而在于网络 I&#x2F;O 与计算机内存大小。</p>
<p>随着网络硬件的进步，内存的扩大，Redis 的性能瓶颈主要在「网络 I&#x2F;O」的处理上，所以在 Redis6.0 之后，<mark>使用多线程来处理网络 I&#x2F;O，但执行命令依旧是用单线程</mark>。</p>
<p>默认情况下，I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会处理读请求（read client socket）。</p>
<p>综上，开启 Redis 后，默认情况下，在主线程 <code>Redis-server</code> 之外，会额外创建 6 个线程：</p>
<ul>
<li><code>BIO_CLOSE_FILE</code>、<code>BIO_AOF_FSYNC</code>、<code>BIO_LAZY_FREE</code>：三个后台线程</li>
<li><code>IO_THD_1</code>、<code>IO_THD_2</code>、<code>IO_THD_3</code>：三个 I&#x2F;O 线程（io-threads 默认为 4，开启 3 个线程比较合适），负责分担网络 I&#x2F;O 压力</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="Redis-如何保证数据不丢失？"><a href="#Redis-如何保证数据不丢失？" class="headerlink" title="Redis 如何保证数据不丢失？"></a>Redis 如何保证数据不丢失？</h3><p>Redis 的读写操作都在内存中进行，如果重启 Redis，内存释放，数据便会丢失。所以，Redis 通过「持久化机制」将数据写入磁盘。</p>
<p>三种持久化方式：</p>
<ul>
<li><code>AOF 日志</code>：全称 Append Only File（追加日志文件），每执行一个「写操作」，也会把「执行命令」记录到一个文件中</li>
<li><code>RDB 快照</code>：全称 Redis Database Backup file（Redis 数据备份文件），将某一时刻的内存数据，以二进制的方式写入磁盘</li>
<li><code>混合持久化方式</code>：AOF + RDB</li>
</ul>
<h3 id="AOF-日志如何实现的？"><a href="#AOF-日志如何实现的？" class="headerlink" title="AOF 日志如何实现的？"></a>AOF 日志如何实现的？</h3><p><img src="/../pictures/image-20230403024702875.png" alt="image-20230403024702875"></p>
<h4 id="为什么要先执行命令，后将命令记录到日志？"><a href="#为什么要先执行命令，后将命令记录到日志？" class="headerlink" title="为什么要先执行命令，后将命令记录到日志？"></a>为什么要先执行命令，后将命令记录到日志？</h4><ul>
<li>好处：<ul>
<li><code>避免额外的检查开销</code>：如果不对执行命令进行检查就先写入日志中，一旦命令有误，那么在恢复时就会发生错误</li>
<li><code>不会阻塞当前命令</code>：记录命令到日志中这个操作也是在主线程中进行的，和当前命令是同步关系，所以先记录日志后执行命令会阻塞当前命令</li>
</ul>
</li>
<li>坏处：<ul>
<li><code>有数据丢失风险</code>：执行完写命令后，在记录日志之前发生宕机，数据丢失</li>
<li><code>可能阻塞其他命令</code>：将当前命令记录到日志中这一操作，虽然不会阻塞当前命令，但可能阻塞后续的命令</li>
</ul>
</li>
</ul>
<h4 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h4><blockquote>
<p>从执行命令到写入磁盘的顺序：</p>
<p>执行写命令 —&gt; 命令追加到 server.aof_buf 缓冲区<em>（还会写到 AOF 重写缓冲区，这个后面会讲）</em> —&gt; I&#x2F;O 系统调用 write()，将 aof_buf 缓冲区数据写入 AOF —&gt; 数据拷贝到内核缓冲区 page cache，等待写入磁盘 —&gt; （等待） —&gt; 真正地写入硬盘</p>
</blockquote>
<p>何时将内核缓冲区的数据真正地写入硬盘，由内核决定，这个决定策略（即写回策略）有三种：</p>
<ul>
<li><code>Always</code>：每次写操作执行完命令后，同步将 AOF 日志数据写回硬盘</li>
<li><code>Everysec</code>：先将数据写入 AOF 文件的内核缓冲区 page cache，然后每隔一秒将缓冲区中的数据写回硬盘</li>
<li><code>No</code>：不由  Redis 控制写回硬盘的时机，由操作系统控制写回时机，即，先将数据写入 AOF 文件的内核缓冲区，再由操作系统决定何时写回硬盘</li>
</ul>
<p><img src="/../pictures/image-20230403024711066.png" alt="image-20230403024711066"></p>
<h4 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h4><p>不断地将写操作的执行命令追加到文件后面，日志文件不断变大，Redis 重启时恢复数据的时间也随之变长。为此，Redis 通过<mark>「AOF 重写机制」</mark>来解决这一问题，当 AOF 文件大小超过设定的阈值时，启动 AOF 重写机制，来压缩 AOF 文件。</p>
<blockquote>
<p>简单来说，就是扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。</p>
</blockquote>
<p>比如：先执行了 <code>set name yby</code> 命令，后执行了 <code>set name yanxx</code> 命令，那么 AOF 日志中会有两条记录，分别对应这两个操作。重写 AOF 时，对于键值对 <code>&lt;name-yanxx&gt;</code> 来说，前一个键值对 <code>&lt;name-yby&gt;</code> 就是过期的，是可以删掉的，所以重写后内存中只保留 <code>&lt;name-yanxx&gt;</code> 这一个键值对，最后将其转为一条命令记录到重写日志中，实现压缩。<em>（这只是一条数据，其他多条数据也是依次执行这个过程。）</em></p>
<p><img src="/../pictures/image-20230403024043687.png" alt="image-20230403024043687"></p>
<p>重写之后，覆盖原来的 AOF 日志文件即可。</p>
<h4 id="重写-AOF-日志过程？"><a href="#重写-AOF-日志过程？" class="headerlink" title="重写 AOF 日志过程？"></a>重写 AOF 日志过程？</h4><p>由后台<mark>子进程</mark> <code>bgrewriteaof</code> 完成。</p>
<p>好处：</p>
<ul>
<li><code>避免阻塞</code>：重写期间，主进程继续处理命令请求，由子进程完成可以避免阻塞</li>
<li><code>性能考虑</code>：由子进程完成，而不是线程，是出于性能的考虑。多线程之间共享内存，修改共享内存数据时需要加锁保证线程安全，导致性能降低。父进程和用来重写的子进程也会共享内存数据，但是以只读的方式共享，父进程或子进程对共享内存数据做出改动时，会发生<mark>「写时复制」</mark>，无需加锁即可保证数据安全</li>
</ul>
<p>重写过程：触发 AOF 重写机制，主进程创建用于重写的子进程，子进程拿到主进程数据的副本，对内存数据只读，逐一将内存数据的键值对转为一条命令，记录到新的 AOF 日志文件。</p>
<blockquote>
<p>在重写的过程中，主进程依然可以正常处理命令，那如果在重写 AOF 日志过程中，主进程修改了一个已存在的键值对，那么此时发生「写时复制」，导致这条数据在子进程和主进程中不一致，如何处理？</p>
<p>答：AOF 重写缓冲区。</p>
</blockquote>
<p>为解决数据不一致问题，Redis 设置了<mark>「AOF 重写缓冲区」</mark>，在创建 <code>bgrewriteaof</code> 子进程之后开始使用。</p>
<p><img src="/../pictures/image-20230403024723435.png" alt="image-20230403024723435"></p>
<p>即，<mark>在重写 AOF 期间</mark>，主进程执行命令之后，会将命令写入「AOF 缓冲区」和「AOF 重写缓冲区」。子进程完成 AOF 重写工作后，向主进程发送一条信号，主进程收到信号后，调用信号处理函数，该函数主要完成两件事：</p>
<ol>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 文件中，使新旧两个 AOF 日志文件所保存的数据库状态一致</li>
<li>将新的 AOF 文件改名，覆盖现有 AOF 文件</li>
</ol>
<p>发现：Redis7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁<br>盘<mark>两次</mark>。</p>
<h3 id="RDB-快照如何实现的？"><a href="#RDB-快照如何实现的？" class="headerlink" title="RDB 快照如何实现的？"></a>RDB 快照如何实现的？</h3><blockquote>
<p>背景：AOF 日志记录的是操作命令，在数据恢复时，需要把所有的日志都执行一遍，如果 AOF 日志文件特别多，恢复速度会比较慢。</p>
<p>解决：使用 RDB 快照</p>
</blockquote>
<p>所谓 RDB 快照，就是记录某一时刻的内存数据，记录的是真实的数据，其恢复效率比 AOF 要高。</p>
<p>但也因为 RDB 每次执行快照时，会把内存中的<mark>所有数据</mark>都记录到磁盘中，如果过于频繁执行 RDB 快照的话，性能会降低。</p>
<h4 id="RDB-会阻塞线程么？"><a href="#RDB-会阻塞线程么？" class="headerlink" title="RDB 会阻塞线程么？"></a>RDB 会阻塞线程么？</h4><p>RDB 快照可以使用两个命令：</p>
<ul>
<li><code>save</code>：在主线程生成 RDB 文件，可能会引起阻塞</li>
<li><code>bgsave</code>：由子进程生成 RDB 文件，不会引起阻塞</li>
</ul>
<h4 id="RDB-过程中可以修改数据么？"><a href="#RDB-过程中可以修改数据么？" class="headerlink" title="RDB 过程中可以修改数据么？"></a>RDB 过程中可以修改数据么？</h4><p>可以的，因为有「写时复制」技术。</p>
<p>在执行 <code>bgsave</code> 命令时，主线程执行了写操作，那么会拷贝一个副本进行修改，RDB 快照里记录的还是旧值。即，主线程在 RDB 快照期间修改的数据需要等到下一次执行 RDB 快照时才能保存到磁盘。</p>
<p>由此，如果系统在 RDB 快照建立完毕后崩溃，那么 Redis 会丢失在执行 RDB 快照期间修改的数据。</p>
<h3 id="AOF-RDB-混合持久化"><a href="#AOF-RDB-混合持久化" class="headerlink" title="AOF + RDB 混合持久化"></a>AOF + RDB 混合持久化</h3><blockquote>
<p>背景：RDB 数据恢复快，但频率不好把控，太低则数据丢失，太高则影响性能；AOF 丢失数据少，但数据恢复可能比较慢。</p>
<p>解决：Redis4.0 混合持久化。</p>
</blockquote>
<p>混合持久化发生在<mark>AOF 日志重写过程</mark>，开启混合持久化后，在 AOF 重写日志时，fork 出子进程会将其与主线程共享的内存数据以 RDB 的方式写入 AOF 日志文件，在此期间主线程的操作命令会记录到<mark>重写缓冲区</mark>，重写缓冲区里的增量命令会以 AOF 的方式写入 AOF 日志文件里，写完后通知主线程覆盖旧日志。</p>
<p>发现：AOF 日志文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p>
<p>好处：</p>
<ul>
<li><code>数据恢复快</code>：恢复数据时，前半部分是 RDB 快照，恢复的更快</li>
<li><code>数据丢失少</code>：后半部分是 AOF 内容，保证更少的数据丢失</li>
</ul>
<p>不足：</p>
<ul>
<li><code>可读性差</code>：AOF 文件里添加了 RDB 格式的内容</li>
<li><code>兼容性差</code>：只适用于 Redis4.0 及其之后的版本</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><h3 id="Redis-如何实现服务高可用？"><a href="#Redis-如何实现服务高可用？" class="headerlink" title="Redis 如何实现服务高可用？"></a>Redis 如何实现服务高可用？</h3><blockquote>
<p>实现高可用可以从三方面谈：主从复制、哨兵模式、切片集群</p>
</blockquote>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制是 Redis 实现高可用的基础，「一主多从，读写分离」：</p>
<ul>
<li>主服务器可以读写，主服务器写时会将写操作同步给从服务器</li>
<li>从服务器只读，同时接收并执行来自主服务器同步过来的写操作命令</li>
</ul>
<p><img src="/../pictures/image-20230403150336742.png" alt="image-20230403150336742"></p>
<blockquote>
<p>主从服务器之间的命令复制是「异步」的。所以很可能发生主从服务器数据不一致的情况，即，无法保证「强一致性」。</p>
<p>强一致性：主从服务器数据时时刻刻都一致。</p>
</blockquote>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><blockquote>
<p>背景：Redis 主服务器宕机，需要手动恢复。</p>
<p>解决：Redis 哨兵模式，监控主从服务器，并提供主从节点故障转移的功能。</p>
</blockquote>
<p><img src="/../pictures/image-20230403150902698.png" alt="image-20230403150902698"></p>
<h4 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h4><blockquote>
<p>背景：Redis 缓存数据量大到一台服务器无法支撑。</p>
<p>解决：Redis 切片集群（Redis Cluster）方案，将数据分布在多个不同的服务器上，降低数据对单个服务器的依赖。</p>
</blockquote>
<p>数据与服务器节点间的映射关系，Redis Cluster 使用哈希槽（Hash Slot）实现：</p>
<ul>
<li>一个切片集群有 16384 个哈希槽，哈希槽类似于分区，每条数据会根据其键值对的 key 映射到一个哈希槽里</li>
<li>哈希槽映射到服务器节点，有两种方案：<ul>
<li><code>平均分配</code>：使用 <code>cluster create</code> 命令创建 Redis 集群时，Redis 将所有哈希槽平均分配给各个服务器节点</li>
<li><code>手动分配</code>：使用 <code>cluster meet</code> 命令手动建立节点间的连接，组成集群，再使用 <code>cluster addslots</code> 命令为每个服务器节点手动分配哈希槽个数（注意，分配时需要将 16384 个哈希槽全部手动分配完，不然 Redis 集群无法工作）</li>
</ul>
</li>
</ul>
<p><img src="/../pictures/image-20230403152047959.png" alt="image-20230403152047959"></p>
<h5 id="集群脑裂怎么办？"><a href="#集群脑裂怎么办？" class="headerlink" title="集群脑裂怎么办？"></a>集群脑裂怎么办？</h5><p>脑裂与解决：</p>
<ul>
<li><p><code>背景</code>：Redis 架构中一般是一主多从，也就是一个主服务器节点负责读写，多个从服务器节点负责只读，主服务器在执行写操作的命令后，从服务器也会执行主服务器的写操作命令，保证主从服务器之间的数据一致。</p>
</li>
<li><p><code>问题出现</code>：如果主服务器（A）<mark>因为网络问题，失去和从服务器的联系</mark>，但此时主服务器（A）和客户端之间的网络没问题</p>
</li>
<li><p><code>问题后果</code>：客户端依旧向主服务（A）中写入数据，这些数据都被主服务器（A）存到缓冲区，因为网络问题，<mark>主服务器（A）无法将写操作命令同步到从服务器</mark>。此时，哨兵发现主服务器失联，在从服务器中选出新的主服务器（B）来接管——「脑裂出现」</p>
</li>
<li><p><code>数据丢失</code>：这时，旧的主服务器（A）和从服务器之间的网络恢复，但因有了新的主服务器（B），<mark>旧的主服务器（A）降为从服务器</mark>，接着向新服务器（B）请求数据同步。因为第一次同步是全量同步，<mark>从服务器（A）清空本地数据，全量同步新的主服务器（B）</mark>。所以，在主从服务器失联期间，客户端向旧的主服务器（A）中写入的数据就会丢失，即，集群脑裂导致数据丢失</p>
</li>
<li><p><code>解决方案</code>：主服务器发现从服务器下线，或通信超时的总数小于自设的阈值时，禁止主服务器执行写操作命令，同时将问题反馈给客户</p>
<ul>
<li>即，主节点至少连接 N 个从节点，从节点和主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则主节点不再接受写请求</li>
</ul>
</li>
</ul>
<h2 id="Redis-过期删除与内存淘汰"><a href="#Redis-过期删除与内存淘汰" class="headerlink" title="Redis 过期删除与内存淘汰"></a>Redis 过期删除与内存淘汰</h2><h3 id="Redis-过期删除策略"><a href="#Redis-过期删除策略" class="headerlink" title="Redis 过期删除策略"></a>Redis 过期删除策略</h3><blockquote>
<p>背景：Redis 可以对 key 设置过期时间，到期后如何删除？——Redis 过期删除策略。</p>
</blockquote>
<p>Redis 会将设置了过期时间的 key 放入「过期字典」中，在查询一个 key 时，Redis 会先查看该 key 是否在过期字典中，如果不在则正常读取键值，如果在则获取该 key 的过期时间，并和系统时间进行比对判断是否过期。</p>
<p>两种策略配合使用：</p>
<ul>
<li><code>惰性删除</code>：不主动删除过期的 key，在查询 key 时再去判断是否过期，如果过期了则删除该 key	<ul>
<li><code>优点</code>：使用系统资源较少，对 CPU 友好</li>
<li><code>缺点</code>：过期的 key 如果一直不被访问到，就一直存在，对内存不友好</li>
</ul>
</li>
<li><code>定期删除</code>：每隔一段时间，「随机」从数据库中取出一定量的 key 进行检查，删除其中过期的 key。如果「已过期的 key 的数量」占比「随机抽取的 key 的数量」大于 25%，则再次抽取进行检查，否则停止检查，隔一段时间再去检查。<ul>
<li><code>优点</code>：限制删除操作执行的时长和频率，减少对 CPU 的影响，减少了过期 key 的无效占用</li>
<li><code>缺点</code>：删除操作的时长和频率不好控制，太频繁对 CPU 不友好，太少又和惰性删除相似</li>
</ul>
</li>
</ul>
<blockquote>
<p>问题：每次抽取过期的 key 都大于 25%，定期删除需要循环很久，怎么办？</p>
<p>解决：为解决定期删除循环过度，设置定期删除循环的时间上限，默认不超过 25ms。</p>
</blockquote>
<h3 id="Redis-持久化时，过期的-key-如何处理？"><a href="#Redis-持久化时，过期的-key-如何处理？" class="headerlink" title="Redis 持久化时，过期的 key 如何处理？"></a>Redis 持久化时，过期的 key 如何处理？</h3><blockquote>
<p>Redis 持久化有两种格式：RDB 和 AOF。从「过期 key 在这两种文件中的状态」这个角度来回答。</p>
</blockquote>
<p>对于 RDB 来说，分为「文件生成」和「文件加载」两个阶段：</p>
<ul>
<li><code>文件生成阶段</code>：过期的 key 不会保存到新的 RDB 中，即，<mark>过期的 key 对 RDB 文件生成无影响</mark></li>
<li><code>文件加载阶段</code>：<ul>
<li><code>加载到主服务器</code>：如果 Redis 是「主服务器」运行模式，则载入 RDB 文件时会检查过期的 key，过期的 key 不会载入到数据库，即，<mark>过期的 key 对 RDB 文件载入主服务器无影响</mark></li>
<li><code>加载到从服务器</code>：如果 Redis 是「从服务器」运行模式，则无论 key 是否过期，都会被载入到数据库。但在主从服务器进行数据同步时，从服务器的数据会被清空，所以一般来说，<mark>过期的 key 对 RDB 文件载入从服务器也无影响</mark></li>
</ul>
</li>
</ul>
<p>对于 AOF 来说，分为「文件写入」和「文件重写」两个阶段：</p>
<ul>
<li><code>AOF 文件写入阶段</code>：AOF 文件会保留尚未删除的过期的 key，待到过期的 key 被删除时，Redis 会向 AOF 追加一条 DEL 命令，显示地删除</li>
<li><code>AOF 文件重写阶段</code>：过期的 key 不会被保存到重写后的 AOF 文件中，即，<mark>过期的 key 对 AOF 文件重写影响</mark></li>
</ul>
<h3 id="Redis-主从模式中，过期的-key-如何处理？"><a href="#Redis-主从模式中，过期的-key-如何处理？" class="headerlink" title="Redis 主从模式中，过期的 key 如何处理？"></a>Redis 主从模式中，过期的 key 如何处理？</h3><ul>
<li>从库不会进行过期扫描，即使从库中的 key 过期了，客户端依然可以读取</li>
<li>主库在识别过期的 key 时，会在 AOF 文件里增加一条 DEL 指令，同步到所有从库，从库通过执行这条 DEL 指令来删除过期的 key</li>
</ul>
<h3 id="Redis-内存满了，会发生什么？"><a href="#Redis-内存满了，会发生什么？" class="headerlink" title="Redis 内存满了，会发生什么？"></a>Redis 内存满了，会发生什么？</h3><p>触发「内存淘汰机制」，阈值就是设置的最大运行内存，配置项为「maxmemory」。</p>
<h3 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h3><ul>
<li><code>noeviction</code>：不进行数据淘汰，超过阈值直接报错。<em>（Redis3.0之后，默认的内存淘汰策略）</em></li>
<li><code>volatile-random</code>：<mark>随机淘汰</mark>设置了过期时间的任意 key</li>
<li><code>volatile-ttl</code>：优先淘汰更早过期的 key</li>
<li><code>volatile-lru</code>：淘汰所有设置了过期时间的 key 中<mark>最久未使用</mark>的 key<em>（Redis3.0 之前，默认的内存淘汰策略）</em></li>
<li><code>volatile-lfu</code>：淘汰所有设置了过期时间的 key 中<mark>最少使用</mark>的 key<em>（Redis 4.0 后新增的内存淘汰策略）</em></li>
<li><code>allkeys-random</code>：<mark>随机</mark>淘汰任意 key</li>
<li><code>allkeys-lru</code>：淘汰整个 key 中<mark>最久未使用</mark>的 key</li>
<li><code>allkeys-lfu</code>：淘汰整个 key 中<mark>最少使用</mark>的 key<em>（Redis 4.0 后新增的内存淘汰策略）</em></li>
</ul>
<h3 id="LRU-与-LFU-算法区别？"><a href="#LRU-与-LFU-算法区别？" class="headerlink" title="LRU 与 LFU 算法区别？"></a>LRU 与 LFU 算法区别？</h3><h4 id="LRU-与-Redis"><a href="#LRU-与-Redis" class="headerlink" title="LRU 与 Redis"></a>LRU 与 Redis</h4><ul>
<li><p><code>传统 LRU 算法</code>：优先淘汰最近最少使用的数据。基于「链表」实现，最新操作的数据移动到链表头，淘汰数据时直接删除链表尾的数据</p>
</li>
<li><p><code>传统 LRU 算法的缺点</code>：</p>
<ul>
<li><p>使用链表缓存数据，造成额外数据开销</p>
</li>
<li><p>大量数据被访问时，带来大量的链表移动操作，耗时</p>
</li>
</ul>
</li>
<li><p><code>Redis 中的 LRU 算法</code>：Redis 采用近似 LRU 算法的方式，在 <mark>Redis 的对象结构体中额外添加一个字段，用于记录最后一次访问时间</mark>，淘汰数据时，随机选取若干数据（可以自定义），然后<mark>淘汰最久没有使用的那个数据</mark></p>
</li>
<li><p><code>Redis 中的 LRU 算法的优点</code>：</p>
<ul>
<li>无需维护大链表，省空间，提升性能</li>
</ul>
</li>
<li><p><code>Redis 中的 LRU 算法的不足</code>：</p>
<ul>
<li><mark>无法解决缓存污染问题</mark>，即，不常用的数据会留存在缓存中很长时间</li>
</ul>
</li>
</ul>
<h4 id="LFU-与-Redis"><a href="#LFU-与-Redis" class="headerlink" title="LFU 与 Redis"></a>LFU 与 Redis</h4><ul>
<li><code>LFU 算法</code>：优先淘汰最近最不常使用的数据，根据访问次数来淘汰数据。</li>
<li><code>Redis 中的 LFU 算法</code>：在 Redis 对象头里有一个 24bit 的 <code>lru</code> 字段，这个字段在 LRU 算法中用来记录访问时间戳，在 LFU 算法中这个字段分为两个部分，高 16bit 记录访问时间戳，低 8bit 记录这个 key 的访问频次</li>
</ul>
<h2 id="Redis-缓存设计"><a href="#Redis-缓存设计" class="headerlink" title="Redis 缓存设计"></a>Redis 缓存设计</h2><h3 id="如何避免缓存雪崩、缓存击穿、缓存穿透"><a href="#如何避免缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="如何避免缓存雪崩、缓存击穿、缓存穿透"></a>如何避免缓存雪崩、缓存击穿、缓存穿透</h3><h4 id="避免缓存雪崩"><a href="#避免缓存雪崩" class="headerlink" title="避免缓存雪崩"></a>避免缓存雪崩</h4><blockquote>
<p>背景：为了保证数据库和 Redis 缓存中的数据一致性，Redis 会给缓存中的数据设置一个过期时间，如果业务系统访问的数据过期，那么业务系统会去访问数据库，并将数据更新到缓存里。</p>
</blockquote>
<p><img src="/../pictures/image-20230403174733105.png" alt="image-20230403174733105"></p>
<p><code>缓存雪崩</code>：大量缓存数据在同一时间过期，恰好此时出现大量用户请求，都无法在 Redis 中得到处理，全部都去直接访问数据库，导致数据库压力骤增，甚至数据库宕机等一系列问题</p>
<p><code>解决</code>：</p>
<ul>
<li><code>打散过期时间</code>：在失效时间上加一个随机值，减小发生雪崩的概率</li>
<li><code>设置缓存不过期</code>：通过后台服务来更新缓存数据</li>
</ul>
<h4 id="避免缓存击穿"><a href="#避免缓存击穿" class="headerlink" title="避免缓存击穿"></a>避免缓存击穿</h4><blockquote>
<p>热点数据：被频繁访问的数据。</p>
</blockquote>
<p><code>缓存击穿</code>：热点数据过期，瞬间向数据库发出大量请求，可以认为「缓存击穿」是「缓存雪崩」的一个子集</p>
<p><code>解决</code>：</p>
<ul>
<li><code>互斥锁</code>：Redis 使用 setNX 方法，保证同一时间只有一个业务线程请求缓存</li>
<li><code>不设置过期时间</code>：不给热点数据设置过期时间，由后台异步更新缓存</li>
</ul>
<h4 id="避免缓存穿透"><a href="#避免缓存穿透" class="headerlink" title="避免缓存穿透"></a>避免缓存穿透</h4><blockquote>
<p>背景：即使发生「缓存雪崩」和「缓存击穿」，数据库里仍有客户端想要访问对应的数据。但对于「缓存穿透」来说，数据既不在缓存中，也不在数据库里。</p>
</blockquote>
<p><code>缓存穿透</code>：</p>
<ul>
<li><code>业务操作有误</code>：缓存中的数据和数据库中的数据都被删除了，导致缓存和数据库中都没有数据</li>
<li><code>黑客攻击</code>：故意大量访问某些读取不存在的数据的业务</li>
</ul>
<p><code>解决</code>：</p>
<ul>
<li><code>非法请求的限制</code>：在 API 入口处判断请求的参数是否合理，是否合法</li>
<li><code>设置空值或默认值</code>：针对业务查询的数据，在缓存中设置一个空值或默认值，防止访问数据库</li>
<li><code>使用布隆过滤器</code>：使用布隆过滤器快速判断数据是否存在，避免通过查询数据来判断数据是否存在</li>
</ul>
<h3 id="如何设计一个缓存策略，可以动态缓存热点数据？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据？"></a>如何设计一个缓存策略，可以动态缓存热点数据？</h3><p>总体思路：<mark>通过数据最新访问时间排名，过滤掉不常访问的数据。</mark></p>
<p>比如，要求只缓存用户经常访问的 TOP1000 的商品：</p>
<ol>
<li>先做一个有序队列，根据商品的访问时间将商品存放到队列中</li>
<li>定期过滤掉后 200 个商品，然后再从数据库中随机读取 200 个商品放入队列中</li>
<li>请求到达时，先从队列中获取商品 id，如果命中，就根据 id 再从另一个缓存数据结构中读取商品信息</li>
<li>Redis 中可以通过 <code>zadd</code> 和 <code>zrange</code> 方法来完成排序和抽取 200 个商品的操作</li>
</ol>
<h3 id="缓存更新的策略"><a href="#缓存更新的策略" class="headerlink" title="缓存更新的策略"></a>缓存更新的策略</h3><p>三种：</p>
<ul>
<li><code>Cache Aside（旁路缓存）策略</code>：最常用，适合「读多写少」的场景<ul>
<li><code>写策略</code>：先更新数据库中的数据，后删除缓存中数据</li>
<li><code>读策略</code>：读操作命中数据，直接返回；否则从数据库中读取并将数据写入缓存</li>
</ul>
</li>
<li><code>Read/Write Through（读穿/写穿）策略</code>：Redis 和 MySQL 用不了</li>
<li><code>Write Back（写回）策略</code>：Redis 和 MySQL 用不了</li>
</ul>
<blockquote>
<p>问：写策略中为什么先删除缓存中的数据，再更新数据库中的数据时，会发生数据不一致的情况？</p>
<p>答：在「读 + 写」并发场景下，A 访问缓存数据 a 失败 —&gt; A 访问数据库数据 a —&gt; B 更新数据库数据 a 为 a’ —&gt; B 删除缓存 —&gt; A 将数据 a 写入缓存。此时数据库中对应的数据为 a’，但缓存中的数据为 a。因此，数据不一致。但发生这种情况的概率很低，因为写入缓存的速度远大于写入数据库的速度。</p>
<p>追问：对数据一致性有严格要求，怎么做？</p>
<p>答：在更新数据时也更新缓存，但在更新缓存之前加一个分布式锁，使得同一时间只有一个线程可以操作该数据，但这样会对写入操作的性能有一定影响；或者是更新数据时也更新缓存，但给缓存数据设置一个较短的过期时间，这样即使出现缓存不一致的情况，数据也会很快过期，对业务的影响比较小。</p>
</blockquote>
<h3 id="😅-数据库和缓存如何保证一致性？"><a href="#😅-数据库和缓存如何保证一致性？" class="headerlink" title="😅 数据库和缓存如何保证一致性？"></a>😅 数据库和缓存如何保证一致性？</h3><h2 id="Redis-实战"><a href="#Redis-实战" class="headerlink" title="Redis 实战"></a>Redis 实战</h2><h3 id="如何实现延迟队列？"><a href="#如何实现延迟队列？" class="headerlink" title="如何实现延迟队列？"></a>如何实现延迟队列？</h3><p>延迟队列使用场景：</p>
<ul>
<li>购物时，超过一定时间未付款，订单失效</li>
<li>点外卖时 10 分钟未接单，自动取消订单</li>
<li>……</li>
</ul>
<p>Redis 通过 <code>ZSet</code> 实现延迟队列，再利用 <code>zrangebysocre</code> 查询符合条件的所有待处理的任务，最后循环执行队列任务即可。</p>
<p><img src="/../pictures/image-20230403215945576.png" alt="image-20230403215945576"></p>
<h3 id="Redis-的大-key-如何处理？"><a href="#Redis-的大-key-如何处理？" class="headerlink" title="Redis 的大 key 如何处理？"></a>Redis 的大 key 如何处理？</h3><p>大 key 表示的是 key 对应的 value 很大，比如 String 类型的值大于 10KB，Hash、Set、List、ZSet 类型的元素个数超过 5000 个。</p>
<p>大 key 带来的影响：</p>
<ul>
<li><code>客户端阻塞超时</code>：操作大 key 比较耗时，从客户端角度看，就是很久没有响应</li>
<li><code>网络阻塞</code>：获取大 key 产生的网络流量大</li>
<li><code>阻塞工作线程</code>：使用 DEL 命令删除大 key，会阻塞主线程</li>
<li><code>内存分布不均</code>：集群模型在槽分片均匀的情况下，出现数据和查询倾斜，QPS（每秒查询率）也会比较大</li>
</ul>
<p>如何找到大 key：</p>
<ul>
<li><code>redis-cli-bigkeys 命令</code></li>
<li><code>SCAN 命令</code></li>
<li><code>RdbTools 工具</code></li>
</ul>
<p>如何删除大 key：</p>
<ul>
<li><code>分批次删除</code>：比如每次获取 N 个字段，每次删除 1 个字段</li>
<li><code>异步删除</code>：Redis4.0 以上，使用 <code>unlink</code> 命令代替 <code>DEL</code> 命令，将大 key 放到一个异步线程中进行删除</li>
</ul>
<h3 id="Redis-管道有什么用？"><a href="#Redis-管道有什么用？" class="headerlink" title="Redis 管道有什么用？"></a>Redis 管道有什么用？</h3><p>Redis 管道是一种「批处理」技术，一次处理多个 Redis 命令，提高交互性能。</p>
<p>管道技术<mark>用来解决多个命令执行时的网络等待</mark>，该技术本质上是客户端提供的功能，而非 Redis。</p>
<h3 id="Redis-支持事务回滚么？"><a href="#Redis-支持事务回滚么？" class="headerlink" title="Redis 支持事务回滚么？"></a>Redis 支持事务回滚么？</h3><p>Redis 本身没有提供回滚机制。（Redis 并不一定保证原子性）</p>
<p>Redis 为什么不支持事务回滚：</p>
<ul>
<li>没必要</li>
<li>不符合 Redis 简单高效的设计初衷</li>
</ul>
<h3 id="😅-如何使用-Redis-实现分布式锁的？"><a href="#😅-如何使用-Redis-实现分布式锁的？" class="headerlink" title="😅 如何使用 Redis 实现分布式锁的？"></a>😅 如何使用 Redis 实现分布式锁的？</h3><blockquote>
<p>分布式锁：一种分布式环境下并发控制机制，控制某个资源在同一时刻只能被一个应用使用。</p>
</blockquote>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Redis" >
    <span class="tag-code">Redis</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/03/28/JVM%20%E9%97%AE%E7%AD%94/">
        <span class="nav-arrow">← </span>
        
          JVM 问答
        
      </a>
    
    
      <a class="nav-right" href="/2023/04/22/ChatGPT%20%E5%B9%B3%E6%9B%BF%EF%BC%9AClaude/">
        
          ChatGPT 平替：Claude
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Redis"><span class="toc-nav-text">Redis</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%AE%80%E4%BB%8B"><span class="toc-nav-text">Redis 简介</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E5%92%8C-Memcached-%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">Redis 和 Memcached 区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis"><span class="toc-nav-text">为什么要用 Redis</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E9%80%9F%E8%A7%88"><span class="toc-nav-text">常见面试题速览</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">Redis 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-nav-text">有哪些数据类型、使用场景？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">五种常见的数据类型是如何实现的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#String"><span class="toc-nav-text">String</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#List"><span class="toc-nav-text">List</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Hash"><span class="toc-nav-text">Hash</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Set"><span class="toc-nav-text">Set</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ZSet"><span class="toc-nav-text">ZSet</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%F0%9F%98%85-Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-nav-text">😅 Redis 数据结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">Redis 线程模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-nav-text">Redis 的单线程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-nav-text">Redis 为什么这么快？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">为什么引入多线程？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-nav-text">Redis 持久化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-nav-text">Redis 如何保证数据不丢失？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">AOF 日志如何实现的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%90%8E%E5%B0%86%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%E5%88%B0%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-nav-text">为什么要先执行命令，后将命令记录到日志？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AOF-%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-nav-text">AOF 写回策略有几种？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E5%A4%A7%EF%BC%8C%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">AOF 日志过大，会触发什么机制？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%87%8D%E5%86%99-AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">重写 AOF 日志过程？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RDB-%E5%BF%AB%E7%85%A7%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">RDB 快照如何实现的？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#RDB-%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">RDB 会阻塞线程么？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#RDB-%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">RDB 过程中可以修改数据么？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#AOF-RDB-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-nav-text">AOF + RDB 混合持久化</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-nav-text">Redis 集群</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-nav-text">Redis 如何实现服务高可用？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-nav-text">主从复制</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-nav-text">哨兵模式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-nav-text">切片集群</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-nav-text">集群脑裂怎么办？</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-nav-text">Redis 过期删除与内存淘汰</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-nav-text">Redis 过期删除策略</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%EF%BC%8C%E8%BF%87%E6%9C%9F%E7%9A%84-key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-nav-text">Redis 持久化时，过期的 key 如何处理？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%9C%9F%E7%9A%84-key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-nav-text">Redis 主从模式中，过期的 key 如何处理？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">Redis 内存满了，会发生什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">Redis 内存淘汰策略有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#LRU-%E4%B8%8E-LFU-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">LRU 与 LFU 算法区别？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#LRU-%E4%B8%8E-Redis"><span class="toc-nav-text">LRU 与 Redis</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#LFU-%E4%B8%8E-Redis"><span class="toc-nav-text">LFU 与 Redis</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-nav-text">Redis 缓存设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-nav-text">如何避免缓存雪崩、缓存击穿、缓存穿透</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-nav-text">避免缓存雪崩</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-nav-text">避免缓存击穿</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-nav-text">避免缓存穿透</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-nav-text">如何设计一个缓存策略，可以动态缓存热点数据？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-nav-text">缓存更新的策略</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%F0%9F%98%85-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-nav-text">😅 数据库和缓存如何保证一致性？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Redis-%E5%AE%9E%E6%88%98"><span class="toc-nav-text">Redis 实战</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-nav-text">如何实现延迟队列？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E7%9A%84%E5%A4%A7-key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-nav-text">Redis 的大 key 如何处理？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-nav-text">Redis 管道有什么用？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">Redis 支持事务回滚么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%F0%9F%98%85-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">😅 如何使用 Redis 实现分布式锁的？</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/04/01/Redis 速览/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>