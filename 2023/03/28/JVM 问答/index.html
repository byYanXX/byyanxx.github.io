<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Stay hungry. Stay foolish.">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      JVM 问答 | yby&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>yby's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">分类</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">发现</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">分类</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">发现</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>JVM 问答</h2>
  <p class="post-date">2023-03-28</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="说一些类加载过程？每个阶段的任务？"><a href="#说一些类加载过程？每个阶段的任务？" class="headerlink" title="说一些类加载过程？每个阶段的任务？"></a>说一些类加载过程？每个阶段的任务？</h3><p>加载 —&gt; 连接（验证 —&gt; 准备 —&gt; 解析） —&gt; 初始化 —&gt; 使用 —&gt; 卸载。</p>
<p>加载：</p>
<ul>
<li>通过「全限定名」获取<mark>二进制字节流</mark></li>
<li>将这个字节流里的<mark>「静态存储结构」转为方法区的「运行时数据结构」</mark></li>
<li>在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区访问堆中数据的<mark>入口</mark></li>
</ul>
<p>连接：</p>
<ul>
<li><code>验证</code>：确保被加载的类的正确性，保证 .class 文件符合虚拟机规范<ul>
<li>文件格式验证，判断是否以 0xCAFEBABE 开头、主次版本号等</li>
<li>元数据验证，对 .class 文件进行「语义分析」，保证信息符合 Java 语言规范</li>
<li>字节码验证，确定语义是否合法，是否符合逻辑</li>
<li>符号引用验证，确保解析动作正确执行</li>
</ul>
</li>
<li><code>准备</code>：在方法区中为类的「静态变量」分配内存，并初始化其「默认值」（注意不是「初值」）<ul>
<li>「实例变量」会在对象实例化时随着对象一起分配到「堆」中</li>
<li>这里初始化的「默认值」指的是「零值」（0、0L、null、false 等），赋予「初值」是在「初始化阶段」执行的</li>
<li>特别地，如果变量被 <code>static final</code> 修饰，那么该字段的字段属性表中会生成 <code>ConstantValue</code> 属性，在准备阶段赋予的不再是默认值，而是「初值」，同时放入常量池，即在准备阶段 <code>public static int a = 3;</code> 初始化 <code>a = 0</code>，<code>public static final int a = 3;</code> 则初始化 <code>a = 3</code></li>
</ul>
</li>
<li><code>解析</code>：将「符号引用」转为「直接引用」<ul>
<li>符号引用，就是一组符号来描述目标，可以是任何字面量</li>
<li>直接引用，直接指向目标的指针、相对偏移量或间接定位到目标的「句柄」</li>
</ul>
</li>
</ul>
<p>初始化：主要是对「类变量」进行初始化，为静态变量赋予「初值」</p>
<ul>
<li><code>初始化步骤</code>：<ul>
<li>判断该类是否被加载、连接，如果还没有，就先执行加载与连接</li>
<li>判断该类的父类是否被初始化，如果还没有，就先对父类进行初始化</li>
<li>依次执行初始化语句</li>
</ul>
</li>
<li><code>初始化时机</code>：只有类被「主动使用」时，才会被初始化，被动使用不会触发初始化，类的主动使用有：<ul>
<li>new 一个对象的时候（实际上 <code>Son son = new Son()</code> 执行的是 <code>Son()</code> 这个构造方法）</li>
<li>对某个类或接口的静态变量进行访问或赋值（读&#x2F;写）</li>
<li>调用类的「静态方法」</li>
<li>通过「反射」调用某个类时，如果该类没有初始化，则会初始化这个类</li>
<li>初始化子类时，父类也会被初始化</li>
<li>JVM 启动时被标位「启动类」的类，即用户指定的主类（包含 main(String[] args) 方法的类）</li>
</ul>
</li>
</ul>
<p>使用：类访问方法区中数据结构的接口，对象则是堆中的数据</p>
<p>卸载：即该类的 Class 对象被 GC。要注意的是，JDK 自带的「启动类加载器」、「扩展类加载器」、「应用程序加载器」的实例是不会被回收卸载的，「自定义类加载器」的实例是可以被回收卸载掉的</p>
<h3 id="JVM-结束生命周期的方式？"><a href="#JVM-结束生命周期的方式？" class="headerlink" title="JVM 结束生命周期的方式？"></a>JVM 结束生命周期的方式？</h3><ul>
<li>执行 <code>System.exit()</code> 方法</li>
<li>程序「正常结束」</li>
<li>程序执行中遇到「异常或错误」</li>
<li>操作系统出现错误</li>
</ul>
<h3 id="加载顺序是固定的么？"><a href="#加载顺序是固定的么？" class="headerlink" title="加载顺序是固定的么？"></a>加载顺序是固定的么？</h3><p>加载、验证、准备和初始化的顺序是确定的，解析不一定，因为 Java 支持动态绑定，所以解析可能会在初始化之后才开始。另外这个顺序是开始的顺序，而非完成的顺序，一般都是交叉混合进行的。</p>
<h3 id="加载-class-文件的方式？"><a href="#加载-class-文件的方式？" class="headerlink" title="加载 .class 文件的方式？"></a>加载 .class 文件的方式？</h3><ul>
<li>从<code>本地系统</code>直接加载</li>
<li><code>网络下载</code> .class 文件</li>
<li>从 <code>zip、jar</code> 等归档文档中加载</li>
<li>从<code>专有数据库</code>中提取</li>
<li>将 Java 文件<code>动态编译</code>为 .class 文件，即在程序运行期间产生 Java 类并编译</li>
</ul>
<h3 id="验证阶段是必须存在的吗？"><a href="#验证阶段是必须存在的吗？" class="headerlink" title="验证阶段是必须存在的吗？"></a>验证阶段是必须存在的吗？</h3><p>验证阶段很重要，但不是必须存在的，验证阶段对程序运行期没有影响，如果引用的类需要反复验证，那么可以考虑使用 <code>-Xverifynone</code> 参数关闭大部分的类验证，缩短 JVM 加载时间。</p>
<h3 id="为什么线程崩溃不会导致-JVM-崩溃？"><a href="#为什么线程崩溃不会导致-JVM-崩溃？" class="headerlink" title="为什么线程崩溃不会导致 JVM 崩溃？"></a>为什么线程崩溃不会导致 JVM 崩溃？</h3><p>正常情况下，操作系统为保证系统安全，会为非法内存访问发送一个 <code>SIGSEGV</code> 信号。在操作系统中默认的信号处理函数会让该进程崩溃，但有时直接让进程崩溃代价太大，所以可以自定义一个信号处理函数去灵活处理，JVM 就是这么做的。</p>
<p>像空指针异常、栈溢出这些问题比较常见，如果一出错就让 JVM 崩溃，这在工程上的代价比较大，所以出于健壮性考虑，JVM 直接让崩溃的线程起死回生，并将错误或异常抛给用户进行处理。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="说一说类加载器的层次？"><a href="#说一说类加载器的层次？" class="headerlink" title="说一说类加载器的层次？"></a>说一说类加载器的层次？</h3><p>类加载器大致有四种，他们之间通过<code>「组合」</code>的方式来表示父子关系。</p>
<ul>
<li><code>Bootstrap ClassLoader</code>：启动类加载器，负责加载存放在 <code>JDK\jre\lib</code> 或由 <code>-Xbootclasspath</code> 参数指定的路径下能被 JVM 识别的类库</li>
<li><code>Extension ClassLoader</code>：扩展类加载器，负责加载存放在 <code>JDK\jre\lib\ext</code> 或由 <code>java.ext.dirs</code> 指定的路径下的所有类库</li>
<li><code>Application ClassLoader</code>：应用程序类加载器，负责加载当前应用 classpath 下的所有 jar 包和类，在没有自定义自己的类加载器的时候，默认使用该类加载器</li>
<li><code>User ClassLoader</code>：自定义类加载器</li>
</ul>
<h3 id="类加载器加载的规则？"><a href="#类加载器加载的规则？" class="headerlink" title="类加载器加载的规则？"></a>类加载器加载的规则？</h3><p>JVM 启动时不会一次性加载出所有类，而是根据需要动态加载，也就是说只有用到了某个类，才会去加载这个类。已加载的类被放在 <code>ClassLoader</code> 这个抽象类里面。类在加载时，系统会先判断这个类是否已经被加载过，如果已加载过就直接返回了，即，相同二进制名称的类只会被加载一次。</p>
<h3 id="类加载的方式？区别？"><a href="#类加载的方式？区别？" class="headerlink" title="类加载的方式？区别？"></a>类加载的方式？区别？</h3><ul>
<li>命令行启动应用时由 JVM 初始化加载</li>
<li>通过 <code>Class.forName()</code> 方法动态加载，将类的 .class 文件加载到 JVM，并执行类中的 static 块，如果加上参数则可以自定义是否要加载 static 块</li>
<li>通过 <code>ClassLoader.loadClass()</code> 方法动态加载，将类的 .class 文件加载到 JVM，不会执行类中的 static 块，在 new 实例时才会执行</li>
</ul>
<h3 id="为什么获取到其父类加载器为-null-就一定是-BootstrapClassLoader-加载的呢？"><a href="#为什么获取到其父类加载器为-null-就一定是-BootstrapClassLoader-加载的呢？" class="headerlink" title="为什么获取到其父类加载器为 null 就一定是 BootstrapClassLoader 加载的呢？"></a>为什么获取到其父类加载器为 null 就一定是 BootstrapClassLoader 加载的呢？</h3><p><code>BootstrapClassLoader</code> 由 C++ 实现，在 Java 中没有与之对应的类，所以拿到的是 null。</p>
<h2 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="有哪些类加载机制？"><a href="#有哪些类加载机制？" class="headerlink" title="有哪些类加载机制？"></a>有哪些类加载机制？</h3><ul>
<li><code>全盘负责</code>：一个类加载负责加载某个类时，这个类所依赖和引用的其他类也都由这个类加载器负责</li>
<li><code>父类委托</code>：先让父类加载器尝试加载当前类，如果父类加载器无法加载，才从自己的类路径中加载这个类</li>
<li><code>缓存机制</code>：所有加载过的类都放入缓存，在调用某个类时会先去缓存中寻找这个类</li>
<li><code>双亲委派机制</code>：类加载器收到类加载的请求后，会将该请求委托给父类加载器，依次向上，直到启动类加载器，如果父类加载器无法完成加载，子加载器才会尝试自己去加载该类</li>
</ul>
<h3 id="双亲委派机制的过程？"><a href="#双亲委派机制的过程？" class="headerlink" title="双亲委派机制的过程？"></a>双亲委派机制的过程？</h3><ol>
<li>「应用程序类加载器」要去加载某个类时，会将这个类加载请求委托给「扩展类加载器」</li>
<li>「扩展类加载器」同样将请求委托给「启动类加载器」</li>
<li>如果「启动类加载器」能够完成类加载请求，就实现类加载，否则交由「扩展类加载器」去完成类加载操作</li>
<li>同样如果「扩展类加载器」无法完成类加载操作，就交由「应用程序类加载器」</li>
<li>最后，如果「应用程序类加载器」也无法完成类加载操作，则抛出「找不到该类」异常（ClassNotFoundException）</li>
</ol>
<h3 id="双亲委派机制的优势？-x2F-为什么需要双亲委派机制？"><a href="#双亲委派机制的优势？-x2F-为什么需要双亲委派机制？" class="headerlink" title="双亲委派机制的优势？&#x2F; 为什么需要双亲委派机制？"></a>双亲委派机制的优势？&#x2F; 为什么需要双亲委派机制？</h3><ol>
<li><code>避免类重复加载</code>：父加载器加载过的类，子加载器不必重新加载这个类，避免类的重复加载，保证 Java 程序的稳定运行</li>
<li><code>安全</code>：该机制可以保证加载的是 jre 里的 Object 类，而不是我自己写的 Object 类，就是防止篡改核心 API，更安全</li>
</ol>
<h3 id="JVM-如何判定两个-Java-类是否相同？"><a href="#JVM-如何判定两个-Java-类是否相同？" class="headerlink" title="JVM 如何判定两个 Java 类是否相同？"></a>JVM 如何判定两个 Java 类是否相同？</h3><ul>
<li>类的「全限定名」是否相同</li>
<li>类的「类加载器」是否一样</li>
</ul>
<p>这两条必须全都一致才能说明这两个 Java 类相同，否则，即使两个类来自同一个 .class 文件，被同一个 JVM 加载，只要它们的类加载器不一样，两个类就绝对不一样。</p>
<h3 id="双亲委派机制如何实现？"><a href="#双亲委派机制如何实现？" class="headerlink" title="双亲委派机制如何实现？"></a>双亲委派机制如何实现？</h3><ul>
<li>检查类是否已经被加载过</li>
<li>如果没被加载过，则调用父加载器的 <code>loadClass()</code> 方法进行加载<em>（这个方法很重要，打破双亲委派就靠重写这个方法）</em></li>
<li>如果父加载器为 null，就检查这个类是否是由启动类加载器加载的类</li>
<li>如果父加载器和启动类加载器都不能完成类加载，就调用自己的 <code>findClass()</code> 方法进行类加载</li>
</ul>
<h3 id="自定义类加载器，如何打破双亲委派机制？如何不打破该机制？"><a href="#自定义类加载器，如何打破双亲委派机制？如何不打破该机制？" class="headerlink" title="自定义类加载器，如何打破双亲委派机制？如何不打破该机制？"></a>自定义类加载器，如何打破双亲委派机制？如何不打破该机制？</h3><p>因为双亲委派过程都是在 <code>loadClass()</code> 方法里的，所以自定义一个继承 <code>ClassLoader</code> 的类加载器去重写这个方法，使其不能执行双亲委派即可。</p>
<p>如果不想打破该机制，那就去重写 <code>findClass()</code> 方法即可。</p>
<h3 id="loadClass-、findClass-、defineClass-的区别？"><a href="#loadClass-、findClass-、defineClass-的区别？" class="headerlink" title="loadClass()、findClass()、defineClass() 的区别？"></a>loadClass()、findClass()、defineClass() 的区别？</h3><ul>
<li><code>loadClass()</code>：主要负责类加载，双亲委派机制就由该方法完成</li>
<li><code>findClass()</code>：根据名称或位置加载 .class 字节码</li>
<li><code>defineClass()</code>：将字节码转为 Class</li>
</ul>
<h3 id="双亲委派被破坏的例子？"><a href="#双亲委派被破坏的例子？" class="headerlink" title="双亲委派被破坏的例子？"></a>双亲委派被破坏的例子？</h3><ul>
<li>在诞生双亲委派机制之前</li>
<li>JNDI、JDBC 等需要加载 SPI 接口实现类</li>
<li>实现热插拔部署工具</li>
<li>Tomcat 等 Web 容器</li>
<li>OSGI、Jigsaw 等模块化技术的应用</li>
</ul>
<h3 id="😅-为什么-JNDI，JDBC-等需要破坏双亲委派？"><a href="#😅-为什么-JNDI，JDBC-等需要破坏双亲委派？" class="headerlink" title="😅 为什么 JNDI，JDBC 等需要破坏双亲委派？"></a>😅 为什么 JNDI，JDBC 等需要破坏双亲委派？</h3><h3 id="为什么-Tomcat-要破坏双亲委派机制？"><a href="#为什么-Tomcat-要破坏双亲委派机制？" class="headerlink" title="为什么 Tomcat 要破坏双亲委派机制？"></a>为什么 Tomcat 要破坏双亲委派机制？</h3><p>Tomcat 是一个 Web 容器，它里面可能部署多个应用程序，不同的应用程序可能依赖同一个第三方类库的不同版本，不同版本的类库其路径名可能是一样的，<mark>如果使用双亲委派机制，就无法加载多个相同的类</mark>，所以 Tomcat 破坏掉双亲委派机制，提供「隔离机制」为每个 Web 容器单独提供一个 WebAppClassLoader 加载器。</p>
<h3 id="😅-谈谈你对模块化技术与类加载机制的了解？"><a href="#😅-谈谈你对模块化技术与类加载机制的了解？" class="headerlink" title="😅 谈谈你对模块化技术与类加载机制的了解？"></a>😅 谈谈你对模块化技术与类加载机制的了解？</h3><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="介绍一下「运行时数据区」？"><a href="#介绍一下「运行时数据区」？" class="headerlink" title="介绍一下「运行时数据区」？"></a>介绍一下「运行时数据区」？</h3><p>线程私有的有<mark>「程序计数器」、「虚拟机栈」、「本地方法栈」</mark>这三个；线程共享的有<mark>「堆」、「方法区」</mark>这两个，位于非运行时方法区「直接内存」也是线程共享的。</p>
<p>1.8 之前，「方法区」位于运行时数据区域，但在 1.8 之后「方法区」移到「本地内存」成为「元空间」。</p>
<h3 id="介绍一下「程序计数器」？"><a href="#介绍一下「程序计数器」？" class="headerlink" title="介绍一下「程序计数器」？"></a>介绍一下「程序计数器」？</h3><ul>
<li>字节码通过改变程序计数器来依次读取指令，实现代码的顺序执行或者循环执行等<mark>「流程控制」</mark></li>
<li>多线程环境下，程序计数器用来记录当前线程的位置，实现<mark>线程之间的切换</mark></li>
<li>它也是唯一一个不会出现「内存溢出」的区域</li>
<li>生命周期随线程的创建而创建，随线程的结束而死亡</li>
</ul>
<h3 id="介绍一下「虚拟机栈」？"><a href="#介绍一下「虚拟机栈」？" class="headerlink" title="介绍一下「虚拟机栈」？"></a>介绍一下「虚拟机栈」？</h3><p>每调用一个方法，就有一个对应的「栈帧」被压入栈，每一个方法调用结束后，就都会有一个栈帧被弹出。</p>
<p>JVM 栈由栈帧组成，每个栈帧包含五个内容：</p>
<ul>
<li><code>局部变量表</code>：主要用于存储「方法参数」和定义在方法体内的「局部变量」，最基本的存储单元是「槽 （Slot）」</li>
<li><code>操作数栈</code>：存放方法执行过程中产生的「中间结果」，以及计算过程中的「临时变量」</li>
<li><code>动态链接</code>：指向「运行时常量池」的方法引用</li>
<li><code>方法返回地址</code>：方法正常退出或异常退出的地址</li>
<li><code>一些附加信息</code>：对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现</li>
</ul>
<p>如果 JVM 栈内存大小固定，栈深度超过最大深度时，抛出「栈溢出」异常。</p>
<p>如果 JVM 栈内存大小可以动态扩展，动态扩展时如果申请不到足够的内存空间，则会抛出「内存溢出」异常。</p>
<h3 id="什么是静态链接？什么是动态链接？"><a href="#什么是静态链接？什么是动态链接？" class="headerlink" title="什么是静态链接？什么是动态链接？"></a>什么是静态链接？什么是动态链接？</h3><ul>
<li><code>静态链接</code>：将字节码文件装载到 JVM 时，如果被调用的方法可以在编译期确定下来，并且运行期间保持不变，这种情况下，将该方法的符号引用转为直接引用的过程就是静态链接</li>
<li><code>动态链接</code>：被调用的方法无法在编译期确定下来，只能在运行期将符号引用转为直接引用，这个过程叫动态链接</li>
</ul>
<h3 id="介绍一下「本地方法栈」？"><a href="#介绍一下「本地方法栈」？" class="headerlink" title="介绍一下「本地方法栈」？"></a>介绍一下「本地方法栈」？</h3><p>Native Method，由 C 语言实现。在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h3 id="介绍一下「堆」？"><a href="#介绍一下「堆」？" class="headerlink" title="介绍一下「堆」？"></a>介绍一下「堆」？</h3><ul>
<li>虚拟机启动时创建</li>
<li>存放「对象实例」与「数组」，「字符串常量池」就是在堆里面的</li>
<li>堆的内存空间在物理上不连续，逻辑上连续</li>
<li>堆也是垃圾回收的主要区域，堆可以分为三部分：<ul>
<li>新生代</li>
<li>老年代</li>
<li>永久代（JDK8 之后被「元空间」取代）</li>
</ul>
</li>
<li>默认初始堆大小为「电脑内存 &#x2F; 64」，默认最大堆内存大小为「电脑内存 &#x2F; 4」</li>
</ul>
<h3 id="堆是分配对象存储的唯一选择吗？"><a href="#堆是分配对象存储的唯一选择吗？" class="headerlink" title="堆是分配对象存储的唯一选择吗？"></a>堆是分配对象存储的唯一选择吗？</h3><p>随着 JIT 编译器的发展，通过逃逸分析，如果某些方法中的对象引用没有被返回或者没有被外面使用，那么对象可以直接在栈上分配内存。</p>
<h3 id="介绍一下「方法区」？"><a href="#介绍一下「方法区」？" class="headerlink" title="介绍一下「方法区」？"></a>介绍一下「方法区」？</h3><ul>
<li>存储<mark>「类元信息」</mark>（类信息、字段信息、方法信息）、<mark>「常量」、「静态变量」、「即时编译器编译后的代码缓存」</mark>等</li>
<li>永久代和元空间是对方法区的两种实现方式</li>
</ul>
<h3 id="为什么要将永久代替换为元空间？"><a href="#为什么要将永久代替换为元空间？" class="headerlink" title="为什么要将永久代替换为元空间？"></a>为什么要将永久代替换为元空间？</h3><p>元空间使用的是本地内存，而永久代是有一个 JVM 设置的上限，这个空间的大小很难确定，导致经常发生内存溢出，使得永久代调优比较困难，所以替换之后发生内存溢出的概率更小了，同时元空间可以加载更多的类。</p>
<h3 id="介绍一下运行时常量池？"><a href="#介绍一下运行时常量池？" class="headerlink" title="介绍一下运行时常量池？"></a>介绍一下运行时常量池？</h3><ul>
<li>方法区中的一部分</li>
<li>编译时期的「字面量」和「符号引用」编译时会存入常量池表，类加载后会存放到方法区的运行时常量池里</li>
</ul>
<blockquote>
<p>JDK1.8 之后：元空间里：运行时常量池 + 静态常量池；堆里：字符串常量池</p>
<p>也就是说，元空间里：final + static final；堆里：String + static</p>
</blockquote>
<h3 id="介绍一下字符串常量池？"><a href="#介绍一下字符串常量池？" class="headerlink" title="介绍一下字符串常量池？"></a>介绍一下字符串常量池？</h3><ul>
<li>为了避免字符串的重复创建，提高性能，减少内存消耗，针对字符串开辟的一块区域</li>
<li>里面保存的是字符串对象的引用，该引用指向堆中的字符串对象</li>
<li>JDK1.7 之前存在于永久代，JDK1.7 之后字符串常量池和静态变量从永久代移动到了堆里面</li>
</ul>
<h3 id="JDK-1-7-为什么要将字符串常量池移动到堆中？"><a href="#JDK-1-7-为什么要将字符串常量池移动到堆中？" class="headerlink" title="JDK 1.7 为什么要将字符串常量池移动到堆中？"></a>JDK 1.7 为什么要将字符串常量池移动到堆中？</h3><p>永久代的 GC 回收率太低，放到堆里面可以高效及时地回收字符串内存。</p>
<h3 id="对象在堆中的的生命周期？分配过程？"><a href="#对象在堆中的的生命周期？分配过程？" class="headerlink" title="对象在堆中的的生命周期？分配过程？"></a>对象在堆中的的生命周期？分配过程？</h3><ol>
<li>堆被划分为新生代和老年代，新生代进一步划分为 Eden 区和 Survivor 区，Survivor 区由 From Survivor 与 To Survivor 组成</li>
<li>创建一个对象后会优先分配到新生代的 Eden 区，同时分配给对象一个「对象年轻计数器」</li>
<li>Eden 区不足时，JVM 执行 Minor GC，将 JVM 中存活的对象转移到 Survivor 区，对象年龄 +1，Survivor 区中的对象也会经历一次 Minor GC，年龄 +1</li>
<li>对象年龄超过阈值（默认 15 次回收标记）后，会被分配到老年代</li>
<li>老年代内存不足时，JVM 执行 Major GC，如果 Major GC 后依然无法存储对象，则 OOM</li>
</ol>
<h3 id="对象的创建过程？"><a href="#对象的创建过程？" class="headerlink" title="对象的创建过程？"></a>对象的创建过程？</h3><ol>
<li>类加载检查</li>
<li>分配内存。两种内存分配方式：「指针碰撞」和「空闲列表」<ul>
<li><code>指针碰撞</code>：用过的内存整合到一边，没用过的内存整合到另一边，中间由指针分隔，挨着指针分配</li>
<li><code>空闲列表</code>：JVM 维护一个列表，列表中记录哪些内存可用，分配时找一块足够大的内存块</li>
</ul>
</li>
<li>初始化零值</li>
<li>设置对象头：Markword + 指向类元信息的指针 + （数组长度）</li>
<li>执行 init 方法</li>
</ol>
<h3 id="对象的内存布局是怎样的？"><a href="#对象的内存布局是怎样的？" class="headerlink" title="对象的内存布局是怎样的？"></a>对象的内存布局是怎样的？</h3><p>三块区域：「对象头」、「实例数据」、「对齐填充」。</p>
<ul>
<li><code>对象头</code>：Markword + 指向类元信息的指针 + （数组长度）</li>
<li><code>实例数据</code>：对象中的有效信息，比如各种字段</li>
<li><code>对齐填充</code>：占位作用，保证对象的大小是 8 字节的整数倍</li>
</ul>
<h3 id="对象的访问方式有哪些？"><a href="#对象的访问方式有哪些？" class="headerlink" title="对象的访问方式有哪些？"></a>对象的访问方式有哪些？</h3><ul>
<li><code>句柄</code>：堆中划分出一块区域作为句柄，内部包含「指向对象实例数据的指针」和「指向对象类型数据的指针」</li>
<li><code>直接指针</code>：存储的就是真实的对象实例数据，内部包含「对象实例数据」和「指向对象类型数据的指针」</li>
</ul>
<p>句柄的优势在于对象被移动时只会改变句柄中的实例数据的指针，句柄本身的地址无需更改，节省了一次指针定位的时间开销，所以速度快。</p>
<h3 id="创建对象时，内存分配并发问题如何解决？"><a href="#创建对象时，内存分配并发问题如何解决？" class="headerlink" title="创建对象时，内存分配并发问题如何解决？"></a>创建对象时，内存分配并发问题如何解决？</h3><ul>
<li><code>CAS</code>：CAS 乐观锁的方式</li>
<li><code>TLAB</code>：预先为每个线程在堆中的 Eden 区分配一块内存，优先在 TLAB 分配，TLAB 空间不够了再 CAS</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="垃圾判断方法"><a href="#垃圾判断方法" class="headerlink" title="垃圾判断方法"></a>垃圾判断方法</h2><h3 id="如何判断一个对象是否可以被回收？"><a href="#如何判断一个对象是否可以被回收？" class="headerlink" title="如何判断一个对象是否可以被回收？"></a>如何判断一个对象是否可以被回收？</h3><ul>
<li><code>引用计数法</code>：为对象添加一个引用计数器，被引用时 +1，引用失效时 -1，为 0 时表示可以被回收<ul>
<li>弊端：两个对象循环引用时，计数器永远不为 0</li>
</ul>
</li>
<li><code>可达性分析法</code>：通过 GC Roots 作为起点进行搜索，能够到达的对象都是存活的，无法到达的对象可以被回收</li>
</ul>
<h3 id="哪些对象可以作为-GC-Roots？"><a href="#哪些对象可以作为-GC-Roots？" class="headerlink" title="哪些对象可以作为 GC Roots？"></a>哪些对象可以作为 GC Roots？</h3><p>JVM 栈中引用的对象、本地方法栈中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、所有被同步锁持有的对象。</p>
<h3 id="对象可以被回收，就一定会被回收吗？"><a href="#对象可以被回收，就一定会被回收吗？" class="headerlink" title="对象可以被回收，就一定会被回收吗？"></a>对象可以被回收，就一定会被回收吗？</h3><p>不一定，一个对象真正被回收之前会经历两次标记过程，比如可达性分析法中不可达的对象如果有必要执行 <code>finalize()</code> 方法则会被第一次标记。所谓是否有必要执行 <code>finalize()</code> 方法，就是如果对象没有覆盖 <code>finalize()</code> 方法或者 <code>finalize()</code> 方法已经被 JVM 调用过时，则认为没有必要执行 <code>finalize()</code> 方法。被标记的对象被放入一个队列中进行第二次标记，除非这个对象和引用链上的任何一个对象建立关联，否则就会被真正回收。</p>
<p><em>（通俗点说，调用 <code>finalize()</code> 方法对象会实现一次“自救”，如果有过一次“自救”，则不会再“自救”。）</em></p>
<h3 id="finalize-方法是什么？"><a href="#finalize-方法是什么？" class="headerlink" title="finalize() 方法是什么？"></a>finalize() 方法是什么？</h3><p>用来做外部资源关闭的方法，当一个对象可以被回收时，会去调用该方法。</p>
<h3 id="引用类型有哪些？"><a href="#引用类型有哪些？" class="headerlink" title="引用类型有哪些？"></a>引用类型有哪些？</h3><ul>
<li><code>强引用</code>：通过 new 的方式创建强引用，绝对不会被垃圾回收</li>
<li><code>软引用</code>：内存不够时，才会被回收，可以提高 JVM 垃圾回收速度，防止 OOM</li>
<li><code>弱引用</code>：一旦被发现，就会被回收，即，只能存活到下一次垃圾回收之前</li>
<li><code>虚引用</code>：和没有引用一样，任何时候都可以被回收，主要被用来跟踪对象被垃圾回收的活动</li>
</ul>
<h3 id="方法区主要回收的是无用的类，如何判断一个类是否是无用的类？"><a href="#方法区主要回收的是无用的类，如何判断一个类是否是无用的类？" class="headerlink" title="方法区主要回收的是无用的类，如何判断一个类是否是无用的类？"></a>方法区主要回收的是无用的类，如何判断一个类是否是无用的类？</h3><p>同时满足如下三条，则认为这个类「可以」被回收：</p>
<ul>
<li>该类的所有实例都已经被回收，即 Java 堆中不存在该类的任何实例</li>
<li>加载这个类的 <code>ClassLoader</code> 已经被回收</li>
<li>这个类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，即，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="垃圾收集算法有哪些？"><a href="#垃圾收集算法有哪些？" class="headerlink" title="垃圾收集算法有哪些？"></a>垃圾收集算法有哪些？</h3><ul>
<li><code>标记-清除</code>：将存活的对象进行标记，清除未被标记的对象<ul>
<li>不足：标记和清除的效率都不高，产生大量内存碎片</li>
</ul>
</li>
<li><code>标记-整理</code>：让存活的对象移动到一端，直接清理端边界意外的内存</li>
<li><code>复制</code>：将内存分为两个区域，每次只使用一块，当一块用完了，就将存活的对象复制到另一块，再把使用过的空间清理掉<ul>
<li>不足：只使用了内存的一半</li>
</ul>
</li>
<li><code>分代收集</code>：根据对象存活周期划分为几块，不同块采用不同的收集算法，老年代使用「标记-清除」或「标记-整理」，新生代使用「复制」</li>
</ul>
<blockquote>
<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
</blockquote>
<h3 id="HotSpot-为什么要分为新生代和老年代？"><a href="#HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="HotSpot 为什么要分为新生代和老年代？"></a>HotSpot 为什么要分为新生代和老年代？</h3><p>因为对象的生命周期不一样，有的对象存活时间短，有的存活时间长。从垃圾收集的角度看，对生命长短不同的对象采用相同的垃圾收集算法肯定是不妥的。</p>
<p>将存活时间相对较短的对象放到新生代中，那么每次垃圾收集时都会有大量死去的对象，那么可以选择「复制」算法，只需付出少量用来复制的成本就可以完成垃圾收集工作。同样将存活时间较长的对象放到老年代中，<mark>因为没有额外的空间对它进行分配担保</mark>，所以必须选择「标记-清除」或「标记-整理」算法。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><ul>
<li>单线程，垃圾回收时必须暂停其他工作线程</li>
<li>新生代使用「复制」算法，老年代使用「标记-整理」算法</li>
<li>简单高效</li>
</ul>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><ul>
<li>Serial 的多线程版本，其他都一样</li>
<li>除了 Serial，只有 ParNew 可以与 CMS 收集器配合工作</li>
<li>默认开启线程的数量和 CPU 相同</li>
</ul>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><ul>
<li>JDK1.8 默认收集器</li>
<li>和 ParNew 很像，但关注点不在收集时的停顿时间，而在与吞吐量（CPU 运行用户代码的时间占总时间的比值），追求的是尽快完成程序任务，而非用户体验</li>
</ul>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><ul>
<li>Serial 的老年代版本，也是单线程</li>
<li>JDK1.5 及之前版本中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为 CMS 收集器的后备方案</li>
</ul>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><ul>
<li>Parallel Scavenge 的老年代版本</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><ul>
<li>追求最短的回收停顿时间</li>
<li>HotSpot JVM 中第一款真正意义上的「并发收集器」，第一次实现了用户线程和垃圾回收线程几乎同时工作</li>
<li>四个步骤：<ul>
<li><code>初始标记</code>：暂停所有线程，记录直接与 GC Roots 关联的对象</li>
<li><code>并发标记</code>：同时开启 GC 和用户线程，追踪记录可达对象，但记录过程中可能会出现新的可达对象，所以无法保证实时性</li>
<li><code>重新标记</code>：修正并发标记期间「因用户线程的继续运行导致标记产生变动的那一部分对象」的标记记录</li>
<li><code>并发清除</code>：开启用户线程，同时 GC 线程开始清理未被标记的区域</li>
</ul>
</li>
<li>不足：<ul>
<li>低回收停顿时间，也就导致吞吐量低，CPU 利用率不够高</li>
<li>无法处理浮动垃圾，浮动垃圾就是并发标记期间「因用户线程的继续运行而产生的垃圾」，这部分垃圾只能在下次 GC 时才能回收，正因为浮动垃圾的存在，所以需要预留出一部分内存，即，CMS 不能等老年代快满时再回收，如果预留空间不足以存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时 JVM 临时启用 Serial Old 来代替 CMS</li>
<li>使用「标记-清除」算法会产生空间碎片，使得老年代里空间有剩余，但没有足够的连续空间存放大对象</li>
</ul>
</li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><ul>
<li>面向服务器的垃圾收集器，既能满足 GC 停顿时间要求，又能满足高吞吐量</li>
<li>步骤：<ul>
<li><code>初始标记</code></li>
<li><code>并发标记</code></li>
<li><code>最终标记</code></li>
<li><code>筛选回收</code></li>
</ul>
</li>
<li>特点：<ul>
<li><code>分代收集</code>：将堆平分为多个大小相等的 Region，新生代和老年代不再物理隔离，也就是说可以对新生代和老年代一起回收</li>
<li><code>空间整合</code>：与 CMS 的「标记-清除」不同，G1 整体上是「标记-整理」，局部上是「复制」</li>
<li><code>可预测的停顿</code>：可以建立可预测的时间模型，使用者可以垃圾收集时间不得超过 N 毫秒</li>
</ul>
</li>
<li>原理：后台维护一个优先列表，根据允许的收集时间，优先选择回收价值最大的分区（Region），从而保证尽可能高的回收效率</li>
</ul>
<h3 id="😅-ZGC-收集器"><a href="#😅-ZGC-收集器" class="headerlink" title="😅 ZGC 收集器"></a>😅 ZGC 收集器</h3><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC、Major-GC、Full-GC？"><a href="#Minor-GC、Major-GC、Full-GC？" class="headerlink" title="Minor GC、Major GC、Full GC？"></a>Minor GC、Major GC、Full GC？</h3><ul>
<li><code>Partial GC</code>：<ul>
<li><code>Minor GC/Young GC</code>：新生代的垃圾收集</li>
<li><code>Major GC/Old GC</code>：老年代的垃圾收集</li>
<li><code>Mixed GC</code>：混合收集，目前只有 G1 有这种行为</li>
</ul>
</li>
<li><code>Full GC</code>：对整个「堆 + 方法区」进行垃圾收集</li>
</ul>
<h3 id="内存分配策略？"><a href="#内存分配策略？" class="headerlink" title="内存分配策略？"></a>内存分配策略？</h3><ul>
<li><code>对象优先在 Eden 区分配</code>：Eden 区空间不足时触发 Minor GC</li>
<li><code>大对象直接放入老年代</code>：「大对象」指的是需要连续内存空间的对象，比如超长的字符串或数组</li>
<li><code>长期存活的对象放入老年代</code>：对象在 Eden 区出生并经过一次 Minor GC 后仍然存活，则为该对象设置一个年龄计数器，每次在 Survivor 区中移动时，年龄就 +1，对象达到一定年龄后（默认 15）移动到老年代</li>
<li><code>动态对象年龄判定</code>：如果 Survivor  区中<mark>相同年龄所有对象大小的总和大于 Survivor 区的一半</mark>时，年龄大于等于该年龄的对象可以直接进入老年代，无需达到年龄阈值</li>
<li><code>空间分配担保</code>：在进行 Minor GC 之前，JVM 会先检查老年代的最大连续空间是否大于新生代所有对象的总空间，如果大于，则认为 Minor GC 安全；否则，JVM 会查看是否允许担保失败，如果允许的话，JVM 检查此时老年代的最大连续空间是否大于过去晋升到老年代的对象的平均大小，如果大于，则 Minor GC，否则 Full GC</li>
</ul>
<h3 id="Full-GC-的触发条件？"><a href="#Full-GC-的触发条件？" class="headerlink" title="Full GC 的触发条件？"></a>Full GC 的触发条件？</h3><ul>
<li><code>调用 System.gc()</code></li>
<li><code>老年代空间不足</code></li>
<li><code>空间分配担保失败</code></li>
<li><code>JDK1.7 及以前的永久代空间不足</code></li>
<li><code>Concurrent Mode Failure</code>：比如 CMS GC 时浮动垃圾太多</li>
</ul>
<h1 id="😅-内存模型"><a href="#😅-内存模型" class="headerlink" title="😅 内存模型"></a>😅 内存模型</h1></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#问答" >
    <span class="tag-code">问答</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/03/18/JUC%20%E9%97%AE%E7%AD%94/">
        <span class="nav-arrow">← </span>
        
          JUC 问答
        
      </a>
    
    
      <a class="nav-right" href="/2023/04/01/Redis%20%E9%80%9F%E8%A7%88/">
        
          Redis 速览
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">类加载机制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">类加载过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%AF%B4%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-nav-text">说一些类加载过程？每个阶段的任务？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#JVM-%E7%BB%93%E6%9D%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-nav-text">JVM 结束生命周期的方式？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">加载顺序是固定的么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8A%A0%E8%BD%BD-class-%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-nav-text">加载 .class 文件的方式？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E6%98%AF%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-nav-text">验证阶段是必须存在的吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4-JVM-%E5%B4%A9%E6%BA%83%EF%BC%9F"><span class="toc-nav-text">为什么线程崩溃不会导致 JVM 崩溃？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">类加载器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%9F"><span class="toc-nav-text">说一说类加载器的层次？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-nav-text">类加载器加载的规则？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">类加载的方式？区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%8E%B7%E5%8F%96%E5%88%B0%E5%85%B6%E7%88%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%BA-null-%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%98%AF-BootstrapClassLoader-%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-nav-text">为什么获取到其父类加载器为 null 就一定是 BootstrapClassLoader 加载的呢？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1"><span class="toc-nav-text">类加载机制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">有哪些类加载机制？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">双亲委派机制的过程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F-x2F-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">双亲委派机制的优势？&#x2F; 为什么需要双亲委派机制？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#JVM-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E4%B8%A4%E4%B8%AA-Java-%E7%B1%BB%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%9F"><span class="toc-nav-text">JVM 如何判定两个 Java 类是否相同？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-nav-text">双亲委派机制如何实现？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E4%B8%8D%E6%89%93%E7%A0%B4%E8%AF%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">自定义类加载器，如何打破双亲委派机制？如何不打破该机制？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#loadClass-%E3%80%81findClass-%E3%80%81defineClass-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-nav-text">loadClass()、findClass()、defineClass() 的区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E8%A2%AB%E7%A0%B4%E5%9D%8F%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-nav-text">双亲委派被破坏的例子？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%F0%9F%98%85-%E4%B8%BA%E4%BB%80%E4%B9%88-JNDI%EF%BC%8CJDBC-%E7%AD%89%E9%9C%80%E8%A6%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="toc-nav-text">😅 为什么 JNDI，JDBC 等需要破坏双亲委派？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Tomcat-%E8%A6%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-nav-text">为什么 Tomcat 要破坏双亲委派机制？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%F0%9F%98%85-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-nav-text">😅 谈谈你对模块化技术与类加载机制的了解？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-nav-text">JVM 内存结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-nav-text">运行时数据区</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「运行时数据区」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「程序计数器」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「虚拟机栈」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9F"><span class="toc-nav-text">什么是静态链接？什么是动态链接？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「本地方法栈」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E5%A0%86%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「堆」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F"><span class="toc-nav-text">堆是分配对象存储的唯一选择吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E3%80%8D%EF%BC%9F"><span class="toc-nav-text">介绍一下「方法区」？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-nav-text">为什么要将永久代替换为元空间？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-nav-text">介绍一下运行时常量池？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-nav-text">介绍一下字符串常量池？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#JDK-1-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%A0%86%E4%B8%AD%EF%BC%9F"><span class="toc-nav-text">JDK 1.7 为什么要将字符串常量池移动到堆中？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">对象在堆中的的生命周期？分配过程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-nav-text">对象的创建过程？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">对象的内存布局是怎样的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">对象的访问方式有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-nav-text">创建对象时，内存分配并发问题如何解决？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-nav-text">垃圾回收</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-nav-text">垃圾判断方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-nav-text">如何判断一个对象是否可以被回收？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA-GC-Roots%EF%BC%9F"><span class="toc-nav-text">哪些对象可以作为 GC Roots？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="toc-nav-text">对象可以被回收，就一定会被回收吗？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#finalize-%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-nav-text">finalize() 方法是什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">引用类型有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BB%E8%A6%81%E5%9B%9E%E6%94%B6%E7%9A%84%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="toc-nav-text">方法区主要回收的是无用的类，如何判断一个类是否是无用的类？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-nav-text">垃圾收集算法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-nav-text">垃圾收集算法有哪些？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-nav-text">HotSpot 为什么要分为新生代和老年代？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">垃圾收集器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Serial 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">ParNew 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Parallel Scavenge 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Serial Old 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Parallel Old 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">CMS 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">G1 收集器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%F0%9F%98%85-ZGC-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">😅 ZGC 收集器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-nav-text">内存分配与回收策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC%EF%BC%9F"><span class="toc-nav-text">Minor GC、Major GC、Full GC？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-nav-text">内存分配策略？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-nav-text">Full GC 的触发条件？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%F0%9F%98%85-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">😅 内存模型</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://by-yanxx.github.io/2023/03/28/JVM 问答/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    <p>Stay hungry. Stay foolish.</p>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>